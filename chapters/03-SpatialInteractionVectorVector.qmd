---
engine: knitr
webr:
  # packages: ['dplyr', 'ggplot2', 'sf']
  cell-options:
    editor-font-scale: 0.8
    out-width: 70%
filters:
  - webr
---

# Spatial Interactions of Vector Data: Subsetting and Joining {#sec-int-vv}

```{r setwd, eval = FALSE, echo = FALSE}
setwd(here::here("chapters"))
```

```{r, include = FALSE, cache = FALSE}
#--- load packages ---#
library(data.table)
library(exactextractr)
library(stringr)
library(sf)
library(ggplot2)
library(raster)
library(tidyverse)
library(tictoc)
library(stargazer)
library(future.apply)
library(lubridate)
```


```{r chap3_figure_setup, echo = FALSE, cache = FALSE}
theme_update(
  axis.title.x = element_text(size = 12, angle = 0, hjust = .5, vjust = -0.3, face = "plain", family = "Times"),
  axis.title.y = element_text(size = 12, angle = 90, hjust = .5, vjust = .9, face = "plain", family = "Times"),
  axis.text.x = element_text(size = 12, angle = 0, hjust = .5, vjust = 1.5, face = "plain", family = "Times"),
  axis.text.y = element_text(size = 12, angle = 0, hjust = 1, vjust = 0, face = "plain", family = "Times"),
  axis.ticks = element_line(size = 0.3, linetype = "solid"),
  # axis.ticks = element_blank(),
  axis.ticks.length = unit(.15, "cm"),
  # axis.ticks.margin = unit(.1,'cm'),
  # axis.text = element_text(margin=unit(.1,'cm')),

  #--- legend ---#
  legend.text = element_text(size = 12, angle = 0, hjust = 0, vjust = 0, face = "plain", family = "Times"),
  legend.title = element_text(size = 12, angle = 0, hjust = 0, vjust = 0, face = "plain", family = "Times"),
  legend.key.size = unit(0.5, "cm"),

  #--- strip (for faceting) ---#
  strip.text = element_text(size = 12, family = "Times"),

  #--- plot title ---#
  plot.title = element_text(family = "Times", face = "bold", size = 12),

  #--- margin ---#
  # plot.margin = margin(0, 0, 0, 0, "cm"),

  #--- panel ---#
  panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(),
  panel.background = element_blank(),
  panel.border = element_rect(fill = NA)
)
```

## Before you start {-}

In this chapter, we explore the spatial interactions between two `sf` objects. We begin by examining topological relations—how two spatial objects relate to each other—focusing on `sf::st_intersects()` and `sf::st_is_within_distance()`. `sf::st_intersects()` is particularly important as it is the most commonly used topological relation and serves as the default for spatial subsetting and joining in `sf`.

Next, we cover spatial subsetting, which involves filtering spatial data based on the geographic features of another dataset. Finally, we will discuss spatial joining, where attribute values from one spatial dataset are assigned to another based on their topological relationship^[For those familiar with the `sp` package, these operations are similar to `sp::over()`.]. 

To test your knowledge, you can work on coding exercises at @sec-exercises-int-vv.

### Direction for replication {-}

**Datasets**

All the datasets that you need to import are available [here](https://www.dropbox.com/sh/vhtpjiezijb97lj/AABpvzqdyZMkR1DgUBeI_mOja?dl=0). In this chapter, the path to files is set relative to my own working directory (which is hidden). To run the codes without having to mess with paths to the files, follow these steps:

+ set a folder (any folder) as the working directory using `setwd()`  
+ create a folder called "Data" inside the folder designated as the working directory (if you have created a "Data" folder previously, skip this step)
+ download the pertinent datasets from [here](https://www.dropbox.com/sh/vhtpjiezijb97lj/AABpvzqdyZMkR1DgUBeI_mOja?dl=0) 
+ place all the files in the downloaded folder in the "Data" folder


**Packages**

Run the following code to install or load (if already installed) the `pacman` package, and then install or load (if already installed) the listed package inside the `pacman::p_load()` function.

```{r Chap_3_packages, cache = F}
if (!require("pacman")) install.packages("pacman")
pacman::p_load(
  sf, # vector data operations
  dplyr, # data wrangling
  data.table, # data wrangling
  ggplot2 # for map creation
)
```

## Topological relations {#sec-topo}

Before diving into spatial subsetting and joining, we first examine topological relations. These refer to how multiple spatial objects are related to each other in space. The `sf` package provides various functions to identify these spatial relationships, with our primary focus being on intersections, which can be identified using `sf::st_intersects()`^[Other topological relations like `st_within()` or `st_touches()` are rarely used.]. We will also briefly explore `sf::st_is_within_distance()`. If you're interested in other topological relations, you can check the documentation with `?geos_binary_pred`.

### Data preparation

We will use three `sf` objects: `points`, `lines`, and `polygons`. 

**POINTS**

```{r create_points}
#--- create points ---#
point_1 <- sf::st_point(c(2, 2))
point_2 <- sf::st_point(c(1, 1))
point_3 <- sf::st_point(c(1, 3))

#--- combine the points to make a single  sf of points ---#
(
points <- 
  list(point_1, point_2, point_3) %>% 
  sf::st_sfc() %>% 
  sf::st_as_sf() %>% 
  dplyr::mutate(point_name = c("point 1", "point 2", "point 3"))
)
```

**LINES**

```{r create_lines}
#--- create points ---#
line_1 <- sf::st_linestring(rbind(c(0, 0), c(2.5, 0.5)))
line_2 <- sf::st_linestring(rbind(c(1.5, 0.5), c(2.5, 2)))

#--- combine the points to make a single  sf of points ---#
(
lines <- 
  list(line_1, line_2) %>% 
  sf::st_sfc() %>% 
  sf::st_as_sf() %>% 
  dplyr::mutate(line_name = c("line 1", "line 2"))
)
```

**POLYGONS**

```{r create_polygons}
#--- create polygons ---#
polygon_1 <- sf::st_polygon(list(
  rbind(c(0, 0), c(2, 0), c(2, 2), c(0, 2), c(0, 0)) 
))

polygon_2 <- sf::st_polygon(list(
  rbind(c(0.5, 1.5), c(0.5, 3.5), c(2.5, 3.5), c(2.5, 1.5), c(0.5, 1.5)) 
))

polygon_3 <- sf::st_polygon(list(
  rbind(c(0.5, 2.5), c(0.5, 3.2), c(2.3, 3.2), c(2, 2), c(0.5, 2.5)) 
))

#--- combine the polygons to make an sf of polygons ---#
(
polygons <- 
  list(polygon_1, polygon_2, polygon_3) %>% 
  sf::st_sfc() %>% 
  sf::st_as_sf() %>% 
  dplyr::mutate(polygon_name = c("polygon 1", "polygon 2", "polygon 3"))
)
```

---

@fig-plot-point-polygons shows how they look together: 

```{r}
#| label: fig-plot-point-polygons
#| fig-cap: "Visualization of the points, lines, and polygons" 
#| code-fold: true 
ggplot() +
  geom_sf(data = polygons, aes(fill = polygon_name), alpha = 0.3) +
  scale_fill_discrete(name = "Polygons") +
  geom_sf(data = lines, aes(color = line_name)) +
  scale_color_discrete(name = "Lines") + 
  geom_sf(data = points, aes(shape = point_name), size = 4) +
  scale_shape_discrete(name = "Points")  
```

### `sf::st_intersects()`

`sf::st_intersects()` identifies which `sfg` object in an `sf` (or `sfc`) intersects with `sfg` object(s) in another `sf`. For example, you can use the function to identify which well is located within which county. `sf::st_intersects()` is the most commonly used topological relation. It is important to understand what it does as it is the default topological relation used when performing spatial subsetting and joining, which we will cover later.  

---

**points and polygons** (@fig-points-polygons)

::: {.column-margin}
```{r}
#| label: fig-points-polygons
#| code-fold: true 
ggplot() +
  geom_sf(data = polygons, aes(fill = polygon_name), alpha = 0.3) +
  scale_fill_discrete(name = "Polygons") +
  geom_sf(data = points, aes(shape = point_name), size = 4) +
  scale_shape_discrete(name = "Points")
```

:::
<!--end of column-margin-->

```{r intersects_point_polygons}
sf::st_intersects(points, polygons)
```

As you can see, the output is a list of which polygon(s) each of the points intersect with. The numbers 1, 2, and 3 in the first row mean that 1st (polygon 1), 2nd (polygon 2), and 3rd (polygon 3) objects of the `polygons` intersect with the first point (point 1) of the `points` object. The fact that point 1 is considered to be intersecting with polygon 2 means that the area inside the border is considered a part of the polygon (of course). 

If you would like the results of `sf::st_intersects()` in a matrix form with boolean values filling the matrix, you can add `sparse = FALSE` option. 

```{r, cache=TRUE}
sf::st_intersects(points, polygons, sparse = FALSE)
```

---

**lines and polygons** (@fig-lines-polygons)

::: {.column-margin}
```{r}
#| label: fig-lines-polygons
#| code-fold: true 
ggplot() +
  geom_sf(data = polygons, aes(fill = polygon_name), alpha = 0.3) +
  scale_fill_discrete(name = "Polygons") +
  geom_sf(data = lines, aes(color = line_name)) +
  scale_color_discrete(name = "Lines")
```

:::
<!--end of column-margin-->

```{r intersects_lines_polygons}
sf::st_intersects(lines, polygons)
```

The output is a list of which polygon(s) each of the lines intersect with. For example, line intersects with the 1st and 2nd elements of `polygons`, which are `polygon 1` and `polygon 2`.

---

**polygons and polygons** (@fig-polygons-polygons)

::: {.column-margin}
```{r}
#| label: fig-polygons-polygons
#| code-fold: true 
ggplot() +
  geom_sf(data = polygons, aes(fill = polygon_name), alpha = 0.3) +
  scale_fill_discrete(name = "Polygons")
```

:::
<!--end of column-margin-->

For polygons vs polygons interaction, `sf::st_intersects()` identifies any polygons that either touches (even at a point like polygons 1 and 3) or share some area.

```{r, cache=TRUE}
sf::st_intersects(polygons, polygons)
```

Clearly, all of them interact with all the polygons (including themselves) in this case.


### `sf::st_is_within_distance()` {#sec-is-within-distance}

This function identifies whether two spatial objects are within the distance you specify^[For example, this function can be useful to identify neighbors. For example, you may want to find irrigation wells located around well $i$ to label them as well $i$'s neighbor.].

We will use two sets of points data.

```{r create_random_points}
#| code-fold: true
set.seed(38424738)

points_set_1 <-
  lapply(1:5, function(x) sf::st_point(runif(2))) %>% 
  sf::st_sfc() %>% sf::st_as_sf() %>% 
  dplyr::mutate(id = 1:nrow(.))

points_set_2 <-
  lapply(1:5, function(x) sf::st_point(runif(2))) %>% 
  sf::st_sfc() %>% sf::st_as_sf() %>% 
  dplyr::mutate(id = 1:nrow(.))
```

```{r}
points_set_1
points_set_2
```

Here is how they are spatially distributed (@fig-map-points-points-points). Instead of circles of points, their corresponding `id` (or equivalently row number here) values are displayed.

```{r}
#| code-fold: true
#| label: fig-map-points-points-points 
#| fig-cap: "The locations of the set of points"
#| 
ggplot() +
  geom_sf_text(data = points_set_1, aes(label = id), color = "red") +
  geom_sf_text(data = points_set_2, aes(label = id), color = "blue") 
```

We want to know which of the blue points (`points_set_2`) are located within 0.2 from each of the red points (`points_set_1`). @fig-points-points-within gives us the answer visually.

```{r}
#| label: fig-points-points-within
#| fig-cap: "The blue points within 0.2 radius of the red points"
#| code-fold: true
#--- create 0.2 buffers around points in points_set_1 ---#
buffer_1 <- sf::st_buffer(points_set_1, dist = 0.2)

ggplot() +
  geom_sf(data = buffer_1, color = "red", fill = NA) +
  geom_sf_text(data = points_set_1, aes(label = id), color = "red") +
  geom_sf_text(data = points_set_2, aes(label = id), color = "blue") 
```

Confirm your visual inspection results with the outcome of the following code using `sf::st_is_within_distance()` function.

```{r within_distance_blue_red}
sf::st_is_within_distance(points_set_1, points_set_2, dist = 0.2)
```

## Spatial cropping

### Data preparation

Let's import the following files: 

```{r hp_import, results = "hide"}
#--- Kansas county borders ---#
KS_counties <-
  readRDS("Data/KS_county_borders.rds") %>%
  sf::st_transform(32614)

#--- High-Plains Aquifer boundary ---#
hpa <- 
  sf::st_read("Data/hp_bound2010.shp") %>%
  .[1, ] %>%
  sf::st_transform(st_crs(KS_counties))

#--- all the irrigation wells in KS ---#
KS_wells <- 
  readRDS("Data/Kansas_wells.rds") %>%
  sf::st_transform(st_crs(KS_counties))

#--- US railroads in the Mid West region ---#
rail_roads_mw <- sf::st_read("Data/mw_railroads.geojson")
```

### Bounding box

We can use `st_crop()` to crop a spatial object to a spatial bounding box (extent) of another spatial object. The bounding box of an `sf` is a rectangle represented by the minimum and maximum of `x` and `y` that encompass/contain all the spatial objects in the `sf`. You can use `st_bbox()` to find the bounding box of an `sf` object. Let's get the bounding box of irrigation wells in Kansas (`KS_wells`).

```{r bbox_KS_wlls}
#--- get the bounding box of KS_wells ---#
(
bbox_KS_wells <- sf::st_bbox(KS_wells)  
)

#--- check the class ---#
class(bbox_KS_wells)
```
 
As you can see, `sf::st_bbox()` returns an object of class `bbox`. You cannot directly create a map using a `bbox`. So, let's convert it to an `sfc` using `sf::st_as_sfc()`:

```{r sfc-county-bbox}
KS_wells_bbox_sfc <- sf::st_as_sfc(bbox_KS_wells) 
```

@fig-bbox-fig shows the bounding box (red rectangle).

```{r}
#| label: fig-bbox-fig
#| fig-cap: "The bounding box of the irrigation wells in Kansas that overlie HPA" 
#| code-fold: true

ggplot() +
  geom_sf(
    data = KS_wells_bbox_sfc, 
    fill = NA,
    color = "red",
    linewidth = 1.2
   ) +
  geom_sf(
    data = KS_wells,
    size = 0.4
  ) +
  theme_void()
```

### Spatial cropping

Let's now crop High-Plains aquifer boundary (`hpa`) to the bounding box of Kansas wells (@fig-hpa).

::: {.column-margin}
```{r}
#| label: fig-hpa
#| fig-cap: "HPA and irrigation wells in Kansas"
#| code-fold: true

ggplot() +
  geom_sf(data = KS_wells, size = 0.4) +
  geom_sf(data = KS_wells_bbox_sfc, fill = NA, color = "red", linewidth = 1) +
  geom_sf(data = hpa, fill = "blue", alpha = 0.3) +
  theme_void()
```

:::
<!--end of column-margin-->

```{r crop_counties}
hpa_cropped_to_KS <- sf::st_crop(hpa, KS_wells)
```

Here is what the cropped version of `hpa` looks like (@fig-cropped-hpa):

```{r}
#| label: fig-cropped-hpa
#| fig-cap: "The bounding box of the irrigation wells in Kansas that overlie HPA"
#| code-fold: true

ggplot() +
  geom_sf(data = KS_wells, size = 0.4) +
  geom_sf(data = KS_wells_bbox_sfc, color = "red", linewidth = 1.2, fill = NA) +
  geom_sf(data = hpa_cropped_to_KS, fill = "blue", alpha = 0.3) +
  theme_void()
```

As you can see, the `st_crop()` operation cut the parts of `hpa` that are not intersecting with the bounding box of `KS_wells`.

:::{.callout-note}
Please note that we did not explicilty crop `hpa` to the bouding box of `KS_wells` (`bbox_KS_wells`) above. That is, we just run `hpa_cropped_to_KS <- sf::st_crop(hpa, KS_wells)` instead of `hpa_cropped_to_KS <- sf::st_crop(hpa, bbox_KS_wells)`. When `sf::st_crop()` is used, it automatically finds the bounding box of the `sf` as second argument and implements cropping.
:::

## Spatial subsetting {#sec-sf-subset}

Spatial subsetting refers to operations that narrow down the geographic scope of a spatial object (source data) based on another spatial object (target data). We illustrate spatial subsetting using Kansas county borders (`KS_counties`), the boundary of the Kansas portion of the High-Plains Aquifer (`hpa_cropped_to_KS`), and agricultural irrigation wells in Kansas (`KS_wells`).

### polygons (source) vs polygons (target)

@fig-overlap-KS-county-HPA shows the Kansas portion of the HPA and Kansas counties.

::: {.column-margin}
```{r}
#| label: fig-overlap-KS-county-HPA
#| fig-cap: "Kansas portion of High-Plains Aquifer and Kansas counties"
#| code-fold: true

ggplot() +
  geom_sf(data = KS_counties) +
  geom_sf(data = hpa_cropped_to_KS, fill = "blue", alpha = 0.3) +
  theme_void()
```
:::
<!--end of column-margin-->

The goal is to select only the counties that intersect with the HPA boundary. Spatial subsetting of `sf` objects follows this syntax:

```{r syntax_subset}
#| eval: false
#--- this does not run ---#
sf_1[sf_2, ]
```

where you are subsetting `sf_1` based on `sf_2`. Instead of row numbers, you provide another sf object in place. The following code spatially subsets Kansas counties based on the HPA boundary.

```{r spatial_subset}
counties_intersecting_hpa <- KS_counties[hpa_cropped_to_KS, ]
```

@fig-default-subset presents counties in `counties_intersecting_hpa` and the cropped HPA boundary.

```{r}
#| code-fold: true
#| fig-cap: "The results of spatially subsetting Kansas counties based on HPA boundary"
#| label: fig-default-subset

ggplot() +
  #--- add US counties layer ---#
  geom_sf(data = counties_intersecting_hpa) +
  #--- add High-Plains Aquifer layer ---#
  geom_sf(data = hpa_cropped_to_KS, fill = "blue", alpha = 0.3) +
  theme_void()
```

You can see that only the counties intersecting with the HPA boundary remain. This is because, when using the syntax `sf_1[sf_2, ]`, the default topological relation is `sf::st_intersects()`. If objects in `sf_1` intersect with any of the objects in `sf_2`, even slightly, they will remain after subsetting.

Sometimes, instead of removing non-intersecting observations, you may just want to flag whether two spatial objects intersect. To do this, you can first retrieve the IDs of the intersecting counties from `counties_intersecting_hpa` and then create a variable in the original dataset (`KS_counties`) that indicates whether an intersection occurs.

```{r county_hpa}
#--- check the intersections of HPA and counties  ---#
intersecting_counties_list <- counties_intersecting_hpa$COUNTYFP

#--- assign true/false ---#
KS_counties <- dplyr::mutate(KS_counties, intersects_hpa = ifelse(COUNTYFP %in% intersecting_counties_list, TRUE, FALSE))

#--- take a look ---#
dplyr::select(KS_counties, COUNTYFP, intersects_hpa)
```

---

**Other topological relations**

As mentioned above, the default topological relation used in `sf_1[sf_2, ]` is `sf::st_intersects()`. However, you can specify other topological relations using the following syntax:

```{r eval = FALSE}
#--- this does not run ---#
sf_1[sf_2, op = topological_relation_type] 
```

For example, if you only want counties that are completely within the HPA boundary, you can use the following approach:  

```{r st_within}
counties_within_hpa <- KS_counties[hpa_cropped_to_KS, op = st_within]
```

@fig-within-subset shows the resulting set of counties.

```{r}
#| label: fig-within-subset
#| fig-cap: "Kansas counties that are completely within the HPA boundary"
#| code-fold: true

ggplot() +
  geom_sf(data = counties_within_hpa) +
  geom_sf(data = hpa_cropped_to_KS, fill = "blue", alpha = 0.3) +
  theme_void()
```

<!-- 
#%%%%%%%%%%%%%%%%%%%%%
# Points vs Polygons 
#%%%%%%%%%%%%%%%%%%%%%
-->

### points (source) vs polygons (target)

The following map (@fig-map-wells-county) shows the Kansas portion of the HPA and all the irrigation wells in Kansas. We can select only wells that reside within the HPA boundary using the same syntax as the above example.

```{r}
#| label: fig-map-wells-county
#| fig-cap: "A map of Kansas irrigation wells and HPA"
#| code-fold: true

ggplot() +
  geom_sf(data = hpa_cropped_to_KS, fill = "blue", alpha = 0.3) +
  geom_sf(data = KS_wells, size = 0.1) +
  theme_void()
```

```{r wells_hpa}
KS_wells_in_hpa <- KS_wells[hpa_cropped_to_KS, ]
```

As you can see in @fig-map-wells-in-hpa below, only the wells that are inside (or intersect with) the HPA remained because the default topological relation is `sf::st_intersects()`.

```{r}
#| label: fig-map-wells-in-hpa
#| fig-cap: "A map of Kansas irrigation wells and HPA"
#| code-fold: true
ggplot() +
  geom_sf(data = hpa_cropped_to_KS, fill = "blue", alpha = 0.3) +
  geom_sf(data = KS_wells_in_hpa, size = 0.1) +
  theme_void()
```

If you want to flag wells that intersect with HPA, use the following approach:

```{r well_hpa_flag}
site_list <- KS_wells_in_hpa$site

(
  KS_wells <- dplyr::mutate(KS_wells, in_hpa = ifelse(site %in% site_list, TRUE, FALSE))
)
```

<!-- 
#%%%%%%%%%%%%%%%%%%%%%
# Lines vs Polygons 
#%%%%%%%%%%%%%%%%%%%%%
-->

### lines (source) vs polygons (target) {#sec-lines_polygons}

@fig-map-lines-county shows the Kansas counties (in red) and U.S. railroads in the Mid West region(in blue).

::: {.column-margin}
```{r}
#| fig-cap: "U.S. railroads and Kansas county boundaries"
#| label: fig-map-lines-county
#| code-fold: true 
#| cache: true

ggplot() +
  geom_sf(data = KS_counties, fill = NA, color = "red") +
  geom_sf(data = rail_roads_mw, color = "blue", linewidth = 0.3) +
  theme_void()
```
:::
<!--end of column-margin-->  

We can select only the railroads that intersect with Kansas.

```{r railroads_ks_county}
railroads_KS <- rail_roads_mw[KS_counties, ]
```

As you can see in @fig-map-rail-ks below, only the railroads that intersect with Kansas were selected. Note the lines that go beyond the Kansas boundary are also selected. Remember, the default is `sf::st_intersect()`. 

```{r}
#| label: fig-map-rail-ks
#| fig-cap: "Railroads that intersect Kansas county boundaries"
#| code-fold: true

ggplot() +
  geom_sf(data = railroads_KS, color = "blue") +
  geom_sf(data = KS_counties, fill = NA) +
  theme_void()
```

If you would like the lines beyond the state boundary to be cut out but the intersecting parts of those lines to remain, use `sf::st_intersection()`, which is explained in @sec-st-intersection.

If you want to flag railroads that intersect with Kansas counties in `railroads`, use the following approach:

```{r lines_ks_flag}
#--- get the list of lines ---#
lines_list <- railroads_KS$LINEARID

#--- railroads ---#
rail_roads_mw <- dplyr::mutate(rail_roads_mw, intersect_ks = ifelse(LINEARID %in% lines_list, TRUE, FALSE))

#--- take a look ---#
dplyr::select(rail_roads_mw, LINEARID, intersect_ks)
```

### polygons (source) vs points (target) {#sec-polygons_points}

::: {.column-margin}
```{r}
#| label: fig-map-county-point
#| fig-cap: "Kansas county boundaries and wells that overlie the HPA"
#| code-fold: true

ggplot() +
  geom_sf(data = KS_counties, fill = NA) +
  geom_sf(data = KS_wells_in_hpa, fill = NA, size = 0.3) +
  theme_void()
```
:::
<!--end of column-margin-->

@fig-map-county-point shows the Kansas counties and irrigation wells in Kansas that overlie HPA. We can select only the counties that intersect with at least one well.

```{r counties_wells}
KS_counties_intersected <- KS_counties[KS_wells_in_hpa, ]  
```

As you can see in @fig-subset-county-point below, only the counties that intersect with at least one well remained.

```{r}
#| label: fig-subset-county-point
#| fig-cap: "Counties that have at least one well"
#| code-fold: true

ggplot() +
  geom_sf(data = KS_counties, fill = NA) +
  geom_sf(data = KS_counties_intersected, fill = "blue", alpha = 0.4) +
  geom_sf(data = KS_wells_in_hpa, fill = NA, size = 0.3) +
  theme_void()
```

## Spatial join {#sec-sp-join}

A spatial join refers to spatial operations that involve the following steps:

+ Overlay one spatial layer (target layer) onto another (source layer).
+ For each observation in the target layer:
+ Identify which objects in the source layer it geographically intersects with (or has another specified topological relationship).
+ Extract values associated with the intersecting objects in the source layer, summarizing if necessary.
+ Assign the extracted values to the corresponding objects in the target layer.

We can classify spatial join into four categories by the type of the underlying spatial objects:

+ **vector-vector**: vector data (target) against vector data (source)
+ **vector-raster**: vector data (target) against raster data (source)
+ **raster-vector**: raster data (target) against vector data (source)
+ **raster-raster**: raster data (target) against raster data (source)

Among these four types, our focus here is on the first case, **vector-vector**. The second case will be discussed in @sec-int-RV. The third and fourth cases are not covered in this book, as the target data is almost always vector data (e.g., cities or farm fields as points, political boundaries as polygons, etc.).

The **vector-vector** category can be further divided into subcategories depending on the type of spatial object: point, line, or polygon. In this context, we will exclude spatial joins involving lines. This is because line objects are rarely used as observation units in subsequent analyses or as the source data for extracting values.^[For example, in @sec-demo-railroad, we did not extract any attribute values from the railroads. Instead, we calculated the travel length of the railroads, meaning the geometry of the railroads was of interest rather than the values associated with them.]

Below is a list of the types of spatial joins we will cover:

1. points (target) against polygons (source)
2. polygons (target) against points (source)
3. polygons (target) against polygons (source)

---

### Spatial join with `sf::st_join()`

To perform spatial join, we can use the `sf::st_join()` function, with the following syntax:

```{r syntax_st_join, eval = FALSE}
#--- this does not run ---#
sf::st_join(target_sf, source_sf)
```

Similar to spatial subsetting, the default topological relation is `sf::st_intersects()`.

#### Case 1: points (target) vs polygons (source)

In this case, for each observation (point) in the target data, it identifies which polygon in the source data it intersects with and then assigns the value associated with the polygon to the point.^[A practical example of this case is shown in Demonstration 1 of @sec-demo.]

We use the Kansas irrigation well data (points) and Kansas county boundary data (polygons) for a demonstration. Our goal is to assign the county-level corn price information from the Kansas county data to wells. First let me create and add a fake county-level corn price variable to the Kansas county data.

```{r create_corn_price}
KS_corn_price <-
  KS_counties %>%
  dplyr::mutate(corn_price = seq(3.2, 3.9, length = nrow(.))) %>%
  dplyr::select(COUNTYFP, corn_price)
```

@fig-map-corn-price presents Kansas counties color-differentiated by the fake corn price.

::: {.column-margin}
```{r}
#| label: fig-map-corn-price
#| fig-cap: "Map of county-level fake corn price" 
#| code-fold: true

ggplot(KS_corn_price) +
  geom_sf(aes(fill = corn_price)) +
  scale_fill_viridis_c() +
  theme_void()
```
:::
<!--end of column-margin-->

For this particular context, the following code will do the job: 

```{r st_join_KS}
#--- spatial join ---#
(
KS_wells_County <- sf::st_join(KS_wells, KS_corn_price)
)
```

You can see from @fig-map-corn-wells that all the wells inside the same county have the same corn price value.

::: {.column-margin}

:::
<!--end of column-margin-->
```{r}
#| label: fig-map-corn-wells
#| fig-cap: "Map of wells color-differentiated by corn price"
#| code-fold: true

ggplot() +
  geom_sf(data = KS_counties) +
  geom_sf(data = KS_wells_County, aes(color = corn_price)) +
  scale_color_viridis_c() +
  theme_void()
```

We can also confirm that the `corn_price` value associated with all the wells in a single county is identical with the `corn_price` value associated with that county in the original corn price data (`KS_corn_price`).

```{r}
KS_wells_County %>%
  dplyr::filter(COUNTYFP == "069") %>%
  dplyr::pull(corn_price) %>%
  unique()

KS_corn_price %>%
  dplyr::filter(COUNTYFP == "069") %>%
  dplyr::pull(corn_price)
```

#### Case 2: polygons (target) vs points (source) {#sec-polygons-points}

In this case, for each observation (polygon) in the target data, it identifies which observations (points) in the source data intersect with it, and then assigns the values associated with those points to the polygon (A practical example of this case is shown in Demonstration 2 of @sec-demo.).

::: {.column-margin}
```{r}
#| label: fig-wells-county-gw
#| fig-cap: "Map of wells color-differentiated by corn price"
#| code-fold: true

ggplot() +
  geom_sf(data = KS_counties) +
  geom_sf(data = KS_wells, aes(color = af_used), size = 0.2) +
  scale_color_viridis_c(name = "Groundwater Pumping (acre-feet)") +
  theme_void() +
  theme(legend.position = "bottom")
```
:::
<!--end of column-margin-->

For instance, if you are conducting a county-level analysis and want to calculate the total groundwater pumping for each county, the target data would be `KS_counties`, and the source data would be `KS_wells` (@fig-wells-county-gw).

```{r st_join_polygon_point}
#--- spatial join ---#
KS_County_wells <- sf::st_join(KS_counties, KS_wells)

#--- take a look ---#
dplyr::select(KS_County_wells, COUNTYFP, site, af_used)
```

As seen in the resulting dataset, each unique polygon-point intersection forms an observation. For each polygon, there will be as many observations as there are wells intersecting with that polygon. After joining the two layers, you can calculate statistics for each polygon (in this case, each county). Since the goal is to calculate groundwater extraction by county, the following code will accomplish this:

```{r summary_after_join}
KS_County_wells %>% 
  dplyr::group_by(COUNTYFP) %>% 
  dplyr::summarize(af_used = sum(af_used, na.rm = TRUE)) 
```

It is just as easy to get other types of statistics by simply modifying the `dplyr::summarize()` part.


#### Case 3: polygons (target) vs polygons (source) {#sec-polygon-polygon}

In this case, `sf::st_join(target_sf, source_sf)` returns all the unique polygon-polygon intersections, with the attributes from `source_sf` attached to the intersecting polygons.

We will use county-level corn acres data in Iowa for 2018 from USDA NASS^[See @sec-nass-quick for instructions on downloading Quick Stats data from within R.] and Hydrologic Units. Our objective is to estimate corn acres by HUC units based on county-level corn acres data.^[There will be substantial measurement errors because the source polygons (corn acres by county) are large compared to the target polygons (HUC units). However, this serves as a useful illustration of a polygon-polygon join.]

We first import the Iowa corn acre data (@fig-map-IA-corn is the map of Iowa counties color-differentiated by corn acres): 

```{r IA_corn_data}
#--- IA boundary ---#
IA_corn <- readRDS("Data/IA_corn.rds")

#--- take a look ---#
IA_corn
```

::: {.column-margin}
```{r}
#| label: fig-map-IA-corn
#| fig-cap: "Map of Iowa counties color-differentiated by corn planted acreage"
#| code-fold: true

ggplot(IA_corn) +
  geom_sf(aes(fill = acres)) +
  scale_fill_viridis_c() +
  theme_void()
```
:::
<!--end of column-margin-->


Now import the HUC units data (@fig-HUC-map presents the map of HUC units):

```{r HUC_import, results = "hide"}
#--- import HUC units ---#
HUC_IA <- 
  sf::st_read("Data/huc250k.shp") %>% 
  dplyr::select(HUC_CODE) %>% 
  #--- reproject to the CRS of IA ---#
  sf::st_transform(st_crs(IA_corn)) %>% 
  #--- select HUC units that overlaps with IA ---#
  .[IA_corn, ]
```

::: {.column-margin}
```{r}
#| label: fig-HUC-map
#| fig-cap: "Map of HUC units that intersect with Iowa state boundary"
#| code-fold: true  

ggplot(HUC_IA) + 
  geom_sf() +
  theme_void()
```
:::
<!--end of column-margin-->

@fig-HUC-county-map presents a map of Iowa counties superimposed on the HUC units:

```{r}
#| label: fig-HUC-county-map
#| fig-cap: "Map of HUC units superimposed on the counties in Iowas"
#| code-fold: true

ggplot() +
  geom_sf(data = HUC_IA) +
  geom_sf(data = IA_corn, aes(fill = acres), alpha = 0.4) +
  scale_fill_viridis_c() +
  theme_void()
```

Spatial join using `sf::st_join()` will produce the following: 

```{r join_HUC_acres}
(
HUC_joined <- sf::st_join(HUC_IA, IA_corn)
)
```

Each intersecting HUC-county combination becomes a separate observation, with the resulting geometry being the same as that of the HUC unit. To illustrate this, let's take a closer look at one of the HUC units. The HUC unit with `HUC_CODE ==10170203` intersects with four County.

```{r filter_the_first_one}
#--- get the HUC unit with `HUC_CODE ==10170203`  ---#
(
temp_HUC_county <- filter(HUC_joined, HUC_CODE == 10170203)
)
```

All of the four observations in `temp_HUC_county` has the identical geometry (@fig-identical-geometry shows this visually.).

```{r}
length(unique(temp_HUC_county$geometry))
```

::: {.column-margin}
```{r}
#| label: fig-identical-geometry
#| fig-cap: "Geoemetry of the four observations in the joined object"
#| code-fold: true 

temp_HUC_county %>%
  dplyr::mutate(county_text = paste0("County Code: ", county_code)) %>%
  ggplot(.) +
  geom_sf() +
  facet_wrap(county_text ~ ., nrow = 2) +
  theme_void()
```
:::
<!--end of column-margin-->

Moreover, they are identical with the geometry of the intersecting HUC unit (the HUC unit with `HUC_CODE ==10170203`):

```{r}
identical(
  #--- geometry of the one of the observations from the joined object ---#
  temp_HUC_county[1, ]$geometry,
  #--- original HUC geometry ---#
  dplyr::filter(HUC_IA, HUC_CODE == 10170203) %>% pull(geometry)
)
```

So, all four observations have identical geometry, which corresponds to the geometry of the HUC unit. This indicates that `sf::st_join()` does not retain information about the extent of the intersection between the HUC unit and the four counties. Keep in mind that the default behavior uses `sf::st_intersects()`, which only checks whether the spatial objects intersect, without providing further details.

If you are calculating a simple average of corn acres and are not concerned with the degree of spatial overlap, this method works just fine. However, if you want to compute an area-weighted average, the information provided is insufficient. You will learn how to calculate the area-weighted average in the next subsection.

### Spatial join and summary in one step

In @sec-polygons-points, we first joined `KS_counties` and `KS_wells` uusing `sf::st_join()` and then applied `dplyr::summarize()` to find total groundwater use per county. This two-step procedure can be done in one step using `aggregate()` with the summarizing function specified for the `FUN` option.

```{r}
#| eval: false
aggregate(source layer, target layer, FUN = function)
```

Since we are trying to find total groundwater use for each county, the target layer is `KS_counties`, the source layer is `KS_wells`, which has `af_used`, and the function to summarize is `sum()`. So, the following code will replicate what we just did above:

```{r demo_aggregate}
#--- sum ---#
aggregate(KS_wells, KS_counties, FUN = sum)
```

Notice that the `sum()` function was applied to all the columns in `KS_wells`, including site id number. So, you might want to select variables you want to join before you apply the `aggregate()` function like this:  

```{r agg_select}
aggregate(dplyr::select(KS_wells, af_used), KS_counties, FUN = sum)
```

### Spatial join with other topological relations

By default, `sf::st_join()` uses `sf::st_intersects()` as the topological relationship. We can use a different topological relationshiop like below:

```{r}
#| eval: false
sf::st_join(sf_1, sf_2, join = \(x, y) st_*(x, y, ...))
```

where `x` and `y` refer to `sf_1` and `sf_2`, respectively. At `...`, you can specify options for `st_*()` you are using. For example, if you are using `st_is_within_distance()`, you need to specificy the `dist` option like below:

```{r}
#| eval: false
sf::st_join(sf_1, sf_2, join = \(x, y) st_is_within_distance(x, y, dist = 5))
```

For demonstration, let's use `points_set_1` and `points_set_2` similar to what we used in @sec-is-within-distance (@fig-map-points-points-join shows which points in `points_set_2` are within 0.2 length of the points in `points_set_1`.). 

```{r}
set.seed(29841)

points_set_1 <-
  lapply(1:5, function(x) sf::st_point(runif(2))) %>%
  sf::st_sfc() %>%
  sf::st_as_sf() %>%
  dplyr::mutate(id_1 = 1:nrow(.))

points_set_2 <-
  lapply(1:5, function(x) sf::st_point(runif(2))) %>%
  sf::st_sfc() %>%
  sf::st_as_sf() %>%
  dplyr::mutate(id_2 = 1:nrow(.))
```

::: {.column-margin}
```{r}
#| code-fold: true
#| label: fig-map-points-points-join
#| fig-cap: "The locations of the set of points"

ggplot() +
  geom_sf(data = sf::st_buffer(points_set_1, dist = 0.2), color = "red", fill = NA) +
  geom_sf_text(data = points_set_1, aes(label = id_1), color = "red") +
  geom_sf_text(data = points_set_2, aes(label = id_2), color = "blue")
```
:::
<!--end of column-margin-->

Let's join `points_set_2` with `points_set_1` with the following code:

```{r}
sf::st_join(points_set_1, points_set_2, join = \(x, y) st_is_within_distance(x, y, dist = 0.2))
```

As you can see the 1st and 3rd points in `points_set_1` are within 0.2 distance from the 5th point in `points_set_2` and are joined together. The 5th point in `points_set_1` is matched with the 3rd and 4th points in `points_set_2`. The join results are consistent with the visual inspection of @fig-map-points-points-join.

## Spatial intersection (cropping join)

Sometimes, you may need to crop spatial objects by polygon boundaries. For instance, in the demonstration in @sec-demo-railroad, we calculated the total length of railroads within each county by trimming the parts of the railroads that extended beyond county boundaries. Similarly, we cannot find area-weighted averages using `sf::st_join()` alone because it does not provide information about how much of each HUC unit intersects with a county. However, if we can obtain the geometry of the intersecting portions of the HUC unit and the county, we can calculate their areas, allowing us to compute area-weighted averages of the joined attributes.

For these purposes, we can use `sf::st_intersection()`. Below, we illustrate how `sf::st_intersection()` works for line-polygon and polygon-polygon intersections (using data generated in @sec-topo). Intersections involving points with `sf::st_intersection()` are equivalent to using `sf::st_join()` since points have neither length nor area (nothing to crop). Therefore, they are not discussed here.

### `sf::st_intersection()` {#sec-st-intersection}

While `sf::st_intersects()` returns the indices of intersecting objects, `sf::st_intersection()` returns the actual intersecting spatial objects, with the non-intersecting parts of the sf objects removed. Additionally, the attribute values from the source sf are merged with the intersecting geometries (`sfg`) in the target `sf`.

::: {.column-margin}
```{r}
#| code-fold: true
#| label: fig-plot-lines-polygons
#| fig-cap: "Visualization of the points, lines, and polygons"

ggplot() +
  geom_sf(data = polygons, aes(fill = polygon_name), alpha = 0.3) +
  scale_fill_discrete(name = "Polygons") +
  geom_sf(data = lines, aes(color = line_name)) +
  scale_color_discrete(name = "Lines") 
```
:::
<!--end of column-margin-->

We will now explore how this works for both line-polygon and polygon-polygon intersections, using the same toy examples we used to demonstrate how `sf::st_intersects()` functions (@fig-plot-lines-polygons shows the lines and polygons).

---

**lines and polygons**

The following code finds the intersection of the lines and the polygons.

```{r lines_polygons_intersection}
(
intersections_lp <- 
  sf::st_intersection(lines, polygons) %>% 
  dplyr::mutate(int_name = paste0(line_name, "-", polygon_name))
)
```

As shown in the output, each intersection between the lines and polygons becomes an observation (e.g., line 1-polygon 1, line 2-polygon 1, and line 2-polygon 2). Any part of the lines that does not intersect with a polygon is removed and does not appear in the returned sf object. To confirm this, see @fig-lines-polygons-int below:

```{r}
#| label: fig-lines-polygons-int
#| fig-cap: "The outcome of the intersections of the lines and polygons"
#| code-fold: true

ggplot() +
  #--- here are all the original polygons  ---#
  geom_sf(data = polygons, aes(fill = polygon_name), alpha = 0.3) +
  #--- here is what is returned after st_intersection ---#
  geom_sf(data = intersections_lp, aes(color = int_name), size = 1.5)
```

This approach also allows us to calculate the length of the line segments that are fully contained within the polygons, similar to what we did in @sec-demo-railroad. Additionally, the attributes (e.g., `polygon_name`) from the source `sf` (the polygons) are merged with their intersecting lines. As a result, `sf::st_intersection()` not only transforms the original geometries but also joins the attributes, which is why I refer to this as a "cropping join."

---

**polygons and polygons**

The following code finds the intersection of polygon 1 and polygon 3 with polygon 2.

```{r, cache=TRUE}
(
intersections_pp <- 
  sf::st_intersection(polygons[c(1,3), ], polygons[2, ]) %>% 
  dplyr::mutate(int_name = paste0(polygon_name, "-", polygon_name.1))
)

```

As shown in @fig-polygons-polygons-int, each intersection between polygons 1 and 3 with polygon 2 becomes a separate observation (e.g., polygon 1-polygon 2 and polygon 3-polygon 2). Similar to the lines-polygons case, the non-intersecting parts of polygons 1 and 3 are removed and do not appear in the returned sf. Later, we will explore how `sf::st_intersection()` can be used to calculate area-weighted values from the intersecting polygons with the help of `sf::st_area()`.

```{r}
#| label: fig-polygons-polygons-int
#| fig-cap: "The outcome of the intersections of polygon 2 and polygons 1 and 3"
#| code-fold: true

ggplot() +
  #--- here are all the original polygons  ---#
  geom_sf(data = polygons, aes(fill = polygon_name), alpha = 0.3) +
  #--- here is what is returned after st_intersection ---#
  geom_sf(data = intersections_pp, aes(fill = int_name))
```

### Area-weighted average

Let’s now return to the example of HUC units and county-level corn acres data from @sec-sp-join. This time, we aim to calculate the area-weighted average of corn acres, rather than just the simple average.

Using `sf::st_intersection()`, we can divide each HUC polygon into parts based on the boundaries of the intersecting counties. For each HUC polygon, the intersecting counties are identified, and the polygon is split according to these boundaries.


```{r intersection}
(
HUC_intersections <- 
  sf::st_intersection(HUC_IA, IA_corn) %>% 
  dplyr::mutate(huc_county = paste0(HUC_CODE, "-", county_code))
)
```

The key difference from the `sf::st_join()` example is that each observation in the returned data represents a unique HUC-county intersection. @fig-inter-ex below shows a map of all the intersections between the HUC unit with `HUC_CODE == 10170203` and its four intersecting counties.

```{r}
#| label: fig-inter-ex
#| fig-cap: "Intersections of a HUC unit and Iowa counties"
#| code-fold: true

ggplot() +
  geom_sf(
    data = dplyr::filter(
      HUC_intersections,
      HUC_CODE == "10170203"
    ),
    aes(fill = huc_county)
  ) +
  scale_fill_viridis_d() +
  theme_void()
```

Note that the attributes from the county data, such as acres, are joined to the resulting intersections, as seen in the output above. As mentioned earlier, `sf::st_intersection()` performs a spetial type of join where the resulting observations are the intersections between the target and source `sf` objects.

To calculate the area-weighted average of corn acres, you can first use `sf::st_area()` to determine the area of each intersection. Then, compute the area-weighted average as follows:


```{r map_area_weighted}
(
HUC_aw_acres <- 
  HUC_intersections %>% 
  #--- get area ---#
  dplyr::mutate(area = as.numeric(st_area(.))) %>% 
  #--- get area-weight by HUC unit ---#
  dplyr::group_by(HUC_CODE) %>% 
  dplyr::mutate(weight = area / sum(area)) %>% 
  #--- calculate area-weighted corn acreage by HUC unit ---#
  dplyr::summarize(aw_acres = sum(weight * acres))
)
```

## Exercises {#sec-exercises-int-vv}

:::{.callout-important}
Before working on exercises, please run the following codes by hitting the **Run Code** button.

```{webr-r}
#| message: false
#| warning: false
library(dplyr)
library(ggplot2)
library(sf)
install.packages(
  "r.spatial.workshop.datasets", 
  repos = c("https://tmieno2.r-universe.dev")
)
library(r.spatial.workshop.datasets)
```
:::

:::{.callout-note title="Tips for working with an `webr` session"}
+ Hit the **Run Code** button to run all the codes in the code area.
+ To run only parts of the code, highlight the section you want to execute with your cursor and then press **Cmd + Return** (Mac) or **Ctrl + Enter** (Windows).
+ All the code blocks are interconnected and R objects defined in one R code block is available in another R code block.
:::


### Exercise 1: Spatially intersecting objects

Find the points in `mower_sensor_sf` that are intersecting with any of the polygons in `fairway_grid`.^[Hint: see @sec-sf-subset]

::: {.panel-tabset}

### Work here
```{webr-r}
data(fairway_grid)
data(mower_sensor)
mower_sensor_sf <- 
  sf::st_as_sf(
    mower_sensor, 
    coords = c("LNG", "LAT"),
    crs = sf::st_crs(fairway_grid)
  )

#--- write codes below  ---#


```

### Answer
```{r, eval = FALSE}
#| code-fold: true
intersecting_points <- mower_sensor_sf[fairway_grid, ]
```

:::

### Exercise 2: Spatial subset and cropping

Run the following codes first and get the sense of their spatial positions:

```{webr-r}
data(hp_boundary)
data(co_counties)

ggplot() +
  geom_sf(data = hp_boundary, fill = "blue", alpha = 0.3) +
  geom_sf(data = co_counties, fill = NA) +
  theme_void()
```

::: {.panel-tabset}

### Problem 1

Find the counties in Colorado that are intersecting with the High-Plains aquifer (`hp_boundary`) and name the resulting R object `subset_co_counties`. If you know how to create a map from `sf` objects using `ggplot2` (@sec-create-maps), then create a map of the intersecting Colorado counties.

::: {.panel-tabset}

#### Work here

```{webr-r}
#--- write codes below  ---#





```

#### Answer
```{r, eval = FALSE}
#| code-fold: true
subset_co_counties <- co_counties[hp_boundary, ]

ggplot(subset_co_counties) +
  geom_sf() +
  theme_void()
```

:::

### Problem 2

Crop the Colorado counties to `hpa_boundary` and name it `cropped_co_counties` If you know how to create a map from `sf` objects using `ggplot2` (@sec-create-maps), then create a map of the cropped Colorado counties (with `aes(fill = "blue, alpha = 0.3)`) on top of all the Colorado counties.

::: {.panel-tabset}

#### Work here

```{webr-r}
#--- write codes below  ---#





```

#### Answer
```{r, eval = FALSE}
#| code-fold: true
cropped_co_counties <- sf::st_crop(co_counties, hp_boundary)

ggplot() +
  geom_sf(data = co_counties) +
  geom_sf(data = cropped_co_counties, fill = "blue", alpha = 0.3) +
  theme_void()
```

:::

### Problem 3

Find the area of counties in `co_counties` (name the column `area`) and `cropped_co_counties` (name the column `area_cropped`). Then, join them together using `left_join` and filter the ones that satisfy `area_cropped < area` to find out which counties were chopped off.

::: {.panel-tabset}

#### Work here

```{webr-r}
#--- write codes below  ---#





```

#### Answer
```{r, eval = FALSE}
#| code-fold: true
subset_co_area <- 
  co_counties %>%
  dplyr::mutate(area = sf::st_area(geometry) %>% as.numeric()) %>%
  #--- make it non-sf so it can be merged with left_join later  ---#
  sf::st_drop_geometry() %>%
  dplyr::select(area, COUNTYFP)

cropped_co_area <- 
  cropped_co_counties %>%
  dplyr::mutate(area_cro = sf::st_area(geometry) %>% as.numeric()) %>%
  #--- make it non-sf so it can be merged with left_join later  ---#
  sf::st_drop_geometry() %>%
  dplyr::select(area_cro, COUNTYFP)

cut_off_counties <- 
  dplyr::left_join(subset_co_area, cropped_co_area, by = "COUNTYFP") %>%
  dplyr::filter(area < area_cro)
```

:::

:::
<!--end of panel-->

### Exercise 3: Spatial join

In this exercise, we will use Nebraska county boundaries (`ne_counties`) and irrigation wells in Nebraska (`wells_ne_sf`).

```{webr-r}
data(ne_counties)
data(wells_ne_sf)

#--- visualize ---#
ggplot() +
  geom_sf(data = ne_counties) +
  geom_sf(data = wells_ne_sf) +
  theme_void()
```

::: {.panel-tabset}

### Problem 1

Spatially join `ne_counties` with `wells_ne_sf` and then find the total amount of groundwater extracted (`gw_extracted`) per county.

::: {.panel-tabset}

### Work here

```{webr-r}





```

### Answer
```{r, eval = FALSE}
#| code-fold: true
sf::st_join(ne_counties, wells_ne_sf) %>%
  #--- geometry no longer neded (makes summary faster later) ---#
  st_drop_geometry() %>%
  dplyr::group_by(countyfp) %>%
  dplyr::summarize(tot_gw = sum(gw_extracted))

```

:::

### Problem 2

Use `aggregate()` instead to do the process implemented in Problem 1 in one step.

::: {.panel-tabset}

### Work here

```{webr-r}





```

### Answer
```{r, eval = FALSE}
#| code-fold: true
aggregate(wells_ne_sf, ne_counties, FUN = sum)
```

:::

:::
<!--end of panel-->

### Exercise 3: Spatial join with a topological relationship other than `sf::st_intersects()`

In this exercise, we use soybean yield (`soy_yield`) and as-applied seed rate (`as_applied_s_rate`) within a production field.

```{webr-r}
#--- soybean yield ---#
data(soy_yield)

#--- seed rate ---#
data(as_applied_s_rate)

#--- visualize ---#
ggplot() +
  geom_sf(data = soy_yield, size = 0.4, color = "red") +
  geom_sf(data = as_applied_s_rate, size = 0.4, color = "darkgreen") +
  theme_void()
```

For each of the yield points, find all the seed rate points within 10 meter. Then, find the average of the neighboring seed rates by yield point.

::: {.panel-tabset}

### Work here

```{webr-r}





```

### Answer
```{r, eval = FALSE}
#| code-fold: true
soy_seed <-
  st_join(
    soy_yield,
    as_applied_s_rate,
    join = \(x, y) st_is_within_distance(x, y, dist = 10)
  )

soy_seed %>%
  st_drop_geometry() %>%
  group_by(yield_id) %>%
  summarize(avg_seed_rate = mean(seed_rate))
```

:::

### Exercise 4: Spatial intersection

In this exercise, you will work with Colorado county borders `co_counties` and the High-Plains aquifer boundary (`hp_boundary`).

```{webr-r}
data(hp_boundary)
data(co_counties)

ggplot() +
  geom_sf(data = hp_boundary, fill = "blue", alpha = 0.3) +
  geom_sf(data = co_counties, fill = NA) +
  theme_void()
```

In your analysis, you want to retain only the counties that have at least 80% of their area overlapping with the aquifer. First, project them to WGS84 UTM Zone 13 (EPSG: 32613) using `sf::st_transform()`, identify these counties using `st_intersection()`, and then create a variable in `co_counties` that indicates whether the 80% overlapping condition is satisfied or not.

::: {.panel-tabset}

### Work here

```{webr-r}
#--- write codes here ---#






```

### Answer
```{r, eval = FALSE}
#| code-fold: true

co_counties_utm13 <- st_transform(co_counties, 32613)
hp_boundary_utm13 <- st_transform(hp_boundary, 32613)

co_intersecting <-
  sf::st_intersection(co_counties_utm13, hp_boundary_utm13) %>%
  dplyr::mutate(area_int = st_area(geometry) %>% as.numeric()) %>%
  sf::st_drop_geometry()

co_counties <- 
  co_counties %>%
  dplyr::mutate(area = st_area(geometry) %>% as.numeric()) %>%
  left_join(., co_intersecting, by = "name") %>%
  dplyr::mutate(more_than_80 = ifelse(area_int > area * 0.8, TRUE, FALSE))
```

:::